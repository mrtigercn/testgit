# !!!compare fman2 with fman1 and fman, we can see what is a reasonable change for reasonable organization of info in different stage!!!

import sqlite3

conn = sqlite3.connect(r'd:\testfmall.db')
cur = conn.cursor()

#cur.execute( 'drop table if exists filelist' )  # include extension in fn as a single search target (but seg particluarly )
# use hash to create fnid? may not unique
cur.execute( 'create table if not exists filelist(fn, path, fnhash)' )  # include extension in fn as a single search target (but seg particluarly )

#cur.execute( 'drop table if exists seglist' )  # include extension in fn as a single search target (but seg particluarly )
cur.execute( 'create table if not exists seglist(seg, fnhash)' ) # use fnid to save storage? assumption:　2*fnid < fn
#cur.execute( 'create table if not exists seglist(seg, fn)' )  # include extension in fn as a single search target (but seg particluarly )

conn.commit()


# get list of root directory    # get file filters
# get all file information
# store file information in a db?
# index seg of fn

# monitor of change???

# search GUI ? 
# get input for search
# name : more than 1 character
# size/time
# op? fuzzy? 

import scandir

def get_filepaths(directory):
    file_paths = []  # List which will store all of the full filepaths.
    for path, subdirs, files in scandir.walk(directory):
        for filename in files:
            filepath = (filename, path, hash(filename))  # better to include extension in fn as a single search target (but seg particluarly )
            # fd = [root]            # fn = filename.rsplit('.', 1)             # if len(fn)==1 then fn.append('')
            # fd.append( fn )   # bad split if some system have no concept of posfix and take . as a normal char
            ## Join the two strings in order to form the full filepath.
            ## os.path.join(root, filename)
            file_paths.append(filepath)  # Add it to the list.
    return file_paths  # Self-explanatory.

def rSubstr(string):
    a=[] #set()
    # better if 2-bytes coding can be identified
    for leftTrunc in range(len(string)):
      a.append(string[leftTrunc:])
    return a


def segStr(string, minl=0, maxl=-1):  # value of len para is str's max index, actual length is 1 + para value
    a=[] #set()
    tmp = string.rsplit( '.', 1 )
    if len(tmp)>1:
      a.append( tmp[1] )
    a.extend( rSubstr(tmp[0]) )
    return a

def _seg(fL):
  segFnList = []
  for fn,path,fnhash in fL:
    segList = segStr(fn)
    for seg in segList:
      segFnList.append( (seg,fnhash) )
  return segFnList


#def _seg(fL):
#  segFnList = []
#  for fn,path,fnhash in fL:
#    segList = rSubstr(fn)
#    for seg in segList:
#      segFnList.append( (seg,fnhash) )
#  return segFnList


mypath='d:\\'
fL = get_filepaths(mypath)

cur.executemany( 'insert into filelist values (?,?,?)', fL )
conn.commit()

cur.executemany( 'insert into seglist values (?,?)', list( set( _seg(fL) ) ) )
conn.commit()




mypath='c:\\'
fL = get_filepaths(mypath)

cur.executemany( 'insert into filelist values (?,?,?)', fL )
conn.commit()

cur.executemany( 'insert into seglist values (?,?)', list( set( _seg(fL) ) ) )
conn.commit()



cur.execute( "create index if not exists seglist_fnhash on seglist (fnhash)" )
#cur.execute( "create index if not exists seglist_fn on seglist (fn)" )
cur.execute( "create index if not exists seglist_seg on seglist (seg)" )

cur.execute( "create index if not exists filelist_fn on filelist (fn)" )
cur.execute( "create index if not exists filelist_path on filelist (path)" )
cur.execute( "create index if not exists filelist_fnhash on filelist (fnhash)" )

conn.commit()


cur.execute('create view seg2fnpath as select seg,fn,path from seglist, filelist where seglist.fnhash == filelist.fnhash')


def search(seg):
  #cur.execute( "select * from seg2fnpath where seg like '?%'", (seg,) )
  #cur.execute( "select * from seg2fnpath where seg like '?'", (seg,) )
  #cur.execute( "select * from seg2fnpath where seg like ?", (seg,) )
  cur.execute( "select * from seg2fnpath where seg like ?", ('%s%%'%seg,) )
  #cur.execute( "select * from seg2fnpath where seg like '%s%%'"%(seg,) )
  i=0
  for r in cur.fetchall():
    print i,r
    i+=1

search('split')
s=u'颜色'
search(s)

cur.execute( "select * from seg2fnpath where seg like 'split%' " )
print cur.fetchone()
for r in cur.fetchall():
  print r


s='ab'
 '%s'%s
 '%s%%'%(s,)

# 在Python3.x中，%格式符已经取消，统一使用format函数进行格式化
fmt_str = "{0} {1} {name} {2} {age}".format("welcome", "boy!", "...", name = "owen", age = 18)
print(fmt_str)

'''
hash重复概率
文件变更
目录
速度再快些？
join准确性？
GUI
映射驱动器？scandir速度？

everything：
  功能扩展？re？?|
  匹配标记？
'''
